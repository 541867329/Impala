From ff95acbad609ca3b6d5522378e0f0624671c7236 Mon Sep 17 00:00:00 2001
From: Josh Elser <elserj@apache.org>
Date: Mon, 30 Mar 2015 16:55:47 -0400
Subject: [PATCH 087/157] HBASE-13335 Use serverHasMoreResults context in
 SmallScanner and SmallReversedScanner.

Use the context passed back via ScanResponse that a RegionServer
fills in to denote whether or not more results existing in the
current Region. Add a simple factory to remove a static method
used across both SmallScanner and SmallReverseScanner. Add new
unit tests for both scanner classes to test scans with and
without the new context (as a quick backward-compatibility test).

Conflicts:
	hbase-client/src/main/java/org/apache/hadoop/hbase/client/ClientSmallScanner.java

Reason: Bug
Author: Josh Elser
Ref: CDH-26958
---
 .../hbase/client/ClientSmallReversedScanner.java   |  136 ++++---
 .../hadoop/hbase/client/ClientSmallScanner.java    |  198 +++++++----
 .../client/TestClientSmallReversedScanner.java     |  372 ++++++++++++++++++++
 .../hbase/client/TestClientSmallScanner.java       |  352 ++++++++++++++++++
 4 files changed, 948 insertions(+), 110 deletions(-)
 create mode 100644 hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestClientSmallReversedScanner.java
 create mode 100644 hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestClientSmallScanner.java

diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/ClientSmallReversedScanner.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/ClientSmallReversedScanner.java
index 46ae53c..18f1b26 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/ClientSmallReversedScanner.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/ClientSmallReversedScanner.java
@@ -29,8 +29,12 @@ import org.apache.hadoop.hbase.Cell;
 import org.apache.hadoop.hbase.HConstants;
 import org.apache.hadoop.hbase.KeyValueUtil;
 import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.client.ClientSmallScanner.SmallScannerCallableFactory;
+import org.apache.hadoop.hbase.ipc.RpcControllerFactory;
 import org.apache.hadoop.hbase.util.Bytes;
 
+import com.google.common.annotations.VisibleForTesting;
+
 import java.io.IOException;
 
 /**
@@ -46,6 +50,7 @@ public class ClientSmallReversedScanner extends ReversedClientScanner {
   private static final Log LOG = LogFactory.getLog(ClientSmallReversedScanner.class);
   private RegionServerCallable<Result[]> smallScanCallable = null;
   private byte[] skipRowOfFirstResult = null;
+  private SmallScannerCallableFactory callableFactory;
 
   /**
    * Create a new ReversibleClientScanner for the specified table Note that the
@@ -59,16 +64,42 @@ public class ClientSmallReversedScanner extends ReversedClientScanner {
    */
   public ClientSmallReversedScanner(Configuration conf, Scan scan, TableName tableName,
                                     HConnection connection) throws IOException {
+    this(conf, scan, tableName, connection, new SmallScannerCallableFactory());
+  }
+
+  /**
+   * Create a new ReversibleClientScanner for the specified table. Take note that the passed
+   * {@link Scan}'s start row may be changed.
+   *
+   * @param conf
+   *          The {@link Configuration} to use.
+   * @param scan
+   *          {@link Scan} to use in this scanner
+   * @param tableName
+   *          The table that we wish to rangeGet
+   * @param connection
+   *          Connection identifying the cluster
+   * @param callableFactory
+   *          Factory used to create the callable for scans
+   * @throws IOException
+   *           If the remote call fails
+   */
+  @VisibleForTesting
+  ClientSmallReversedScanner(Configuration conf, Scan scan, TableName tableName,
+      HConnection connection, SmallScannerCallableFactory callableFactory) throws IOException {
     super(conf, scan, tableName, connection);
+    this.callableFactory = callableFactory;
   }
 
   /**
-   * Gets a scanner for following scan. Move to next region or continue from the
-   * last result or start from the start row.
+   * Gets a scanner for following scan. Move to next region or continue from the last result or
+   * start from the start row.
    *
    * @param nbRows
-   * @param done              true if Server-side says we're done scanning.
-   * @param currentRegionDone true if scan is over on current region
+   * @param done
+   *          true if Server-side says we're done scanning.
+   * @param currentRegionDone
+   *          true if scan is over on current region
    * @return true if has next scanner
    * @throws IOException
    */
@@ -108,7 +139,7 @@ public class ClientSmallReversedScanner extends ReversedClientScanner {
           + Bytes.toStringBinary(localStartKey) + "'");
     }
 
-    smallScanCallable = ClientSmallScanner.getSmallScanCallable(
+    smallScanCallable = callableFactory.getCallable(
         scan, getConnection(), getTable(), localStartKey, cacheNum, this.rpcControllerFactory);
 
     if (this.scanMetrics != null && skipRowOfFirstResult == null) {
@@ -125,43 +156,7 @@ public class ClientSmallReversedScanner extends ReversedClientScanner {
       return null;
     }
     if (cache.size() == 0) {
-      Result[] values = null;
-      long remainingResultSize = maxScannerResultSize;
-      int countdown = this.caching;
-      boolean currentRegionDone = false;
-      // Values == null means server-side filter has determined we must STOP
-      while (remainingResultSize > 0 && countdown > 0
-          && nextScanner(countdown, values == null, currentRegionDone)) {
-        // Server returns a null values if scanning is to stop. Else,
-        // returns an empty array if scanning is to go on and we've just
-        // exhausted current region.
-        // TODO use context from server
-        values = this.caller.callWithRetries(smallScanCallable, scannerTimeout);
-        this.currentRegion = smallScanCallable.getHRegionInfo();
-        long currentTime = System.currentTimeMillis();
-        if (this.scanMetrics != null) {
-          this.scanMetrics.sumOfMillisSecBetweenNexts.addAndGet(currentTime
-              - lastNext);
-        }
-        lastNext = currentTime;
-        if (values != null && values.length > 0) {
-          for (int i = 0; i < values.length; i++) {
-            Result rs = values[i];
-            if (i == 0 && this.skipRowOfFirstResult != null
-                && Bytes.equals(skipRowOfFirstResult, rs.getRow())) {
-              // Skip the first result
-              continue;
-            }
-            cache.add(rs);
-            for (Cell kv : rs.rawCells()) {
-              remainingResultSize -= KeyValueUtil.ensureKeyValue(kv).heapSize();
-            }
-            countdown--;
-            this.lastResult = rs;
-          }
-        }
-        currentRegionDone = countdown > 0;
-      }
+      loadCache();
     }
 
     if (cache.size() > 0) {
@@ -173,6 +168,49 @@ public class ClientSmallReversedScanner extends ReversedClientScanner {
     return null;
   }
 
+  @Override
+  protected void loadCache() throws IOException {
+    Result[] values = null;
+    long remainingResultSize = maxScannerResultSize;
+    int countdown = this.caching;
+    boolean currentRegionDone = false;
+    // Values == null means server-side filter has determined we must STOP
+    while (remainingResultSize > 0 && countdown > 0
+        && nextScanner(countdown, values == null, currentRegionDone)) {
+      // Server returns a null values if scanning is to stop. Else,
+      // returns an empty array if scanning is to go on and we've just
+      // exhausted current region.
+      values = this.caller.callWithRetries(smallScanCallable, scannerTimeout);
+      this.currentRegion = smallScanCallable.getHRegionInfo();
+      long currentTime = System.currentTimeMillis();
+      if (this.scanMetrics != null) {
+        this.scanMetrics.sumOfMillisSecBetweenNexts.addAndGet(currentTime
+            - lastNext);
+      }
+      lastNext = currentTime;
+      if (values != null && values.length > 0) {
+        for (int i = 0; i < values.length; i++) {
+          Result rs = values[i];
+          if (i == 0 && this.skipRowOfFirstResult != null
+              && Bytes.equals(skipRowOfFirstResult, rs.getRow())) {
+            // Skip the first result
+            continue;
+          }
+          cache.add(rs);
+          for (Cell kv : rs.rawCells()) {
+            remainingResultSize -= KeyValueUtil.ensureKeyValue(kv).heapSize();
+          }
+          countdown--;
+          this.lastResult = rs;
+        }
+      }
+      if (smallScanCallable.hasMoreResultsContext()) {
+        currentRegionDone = !smallScanCallable.getServerHasMoreResults();
+      } else {
+        currentRegionDone = countdown > 0;
+      }
+    }
+  }
 
   @Override
   protected void initializeScannerInConstruction() throws IOException {
@@ -186,4 +224,18 @@ public class ClientSmallReversedScanner extends ReversedClientScanner {
     closed = true;
   }
 
+  @VisibleForTesting
+  protected void setScannerCallableFactory(SmallScannerCallableFactory callableFactory) {
+    this.callableFactory = callableFactory;
+  }
+
+  @VisibleForTesting
+  protected void setRpcRetryingCaller(RpcRetryingCaller<Result []> caller) {
+    this.caller = caller;
+  }
+
+  @VisibleForTesting
+  protected void setRpcControllerFactory(RpcControllerFactory rpcControllerFactory) {
+    this.rpcControllerFactory = rpcControllerFactory;
+  }
 }
diff --git a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/ClientSmallScanner.java b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/ClientSmallScanner.java
index 83797e4..66346c3 100644
--- a/hbase-client/src/main/java/org/apache/hadoop/hbase/client/ClientSmallScanner.java
+++ b/hbase-client/src/main/java/org/apache/hadoop/hbase/client/ClientSmallScanner.java
@@ -38,6 +38,7 @@ import org.apache.hadoop.hbase.protobuf.generated.ClientProtos.ScanRequest;
 import org.apache.hadoop.hbase.protobuf.generated.ClientProtos.ScanResponse;
 import org.apache.hadoop.hbase.util.Bytes;
 
+import com.google.common.annotations.VisibleForTesting;
 import com.google.protobuf.ServiceException;
 
 /**
@@ -55,6 +56,7 @@ public class ClientSmallScanner extends ClientScanner {
   // When fetching results from server, skip the first result if it has the same
   // row with this one
   private byte[] skipRowOfFirstResult = null;
+  private SmallScannerCallableFactory callableFactory;
 
   /**
    * Create a new ClientSmallScanner for the specified table. An HConnection
@@ -108,11 +110,42 @@ public class ClientSmallScanner extends ClientScanner {
    * @param rpcFactory
    * @param controllerFactory 
    * @throws IOException
+   *           If the remote call fails
    */
   public ClientSmallScanner(final Configuration conf, final Scan scan, final TableName tableName,
       HConnection connection, RpcRetryingCallerFactory rpcFactory,
       RpcControllerFactory controllerFactory) throws IOException {
+    this(conf, scan, tableName, connection, rpcFactory, controllerFactory, new SmallScannerCallableFactory());
+  }
+
+  /**
+   * Create a new ShortClientScanner for the specified table. Take note that the passed {@link Scan}
+   * 's start row maybe changed changed. Intended for unit tests to provide their own
+   * {@link SmallScannerCallableFactory} implementation/mock.
+   *
+   * @param conf
+   *          The {@link Configuration} to use.
+   * @param scan
+   *          {@link Scan} to use in this scanner
+   * @param tableName
+   *          The table that we wish to rangeGet
+   * @param connection
+   *          Connection identifying the cluster
+   * @param rpcFactory
+   *          Factory used to create the {@link RpcRetryingCaller}
+   * @param controllerFactory
+   *          Factory used to access RPC payloads
+   * @param callableFactory
+   *          Factory used to create the callable for this scan
+   * @throws IOException
+   */
+  @VisibleForTesting
+  ClientSmallScanner(final Configuration conf, final Scan scan, final TableName tableName,
+      HConnection connection, RpcRetryingCallerFactory rpcFactory,
+      RpcControllerFactory controllerFactory, SmallScannerCallableFactory callableFactory)
+      throws IOException {
     super(conf, scan, tableName, connection, rpcFactory, controllerFactory);
+    this.callableFactory = callableFactory;
   }
 
   @Override
@@ -163,7 +196,7 @@ public class ClientSmallScanner extends ClientScanner {
       LOG.trace("Advancing internal small scanner to startKey at '"
           + Bytes.toStringBinary(localStartKey) + "'");
     }
-    smallScanCallable = getSmallScanCallable(
+    smallScanCallable = callableFactory.getCallable(
         scan, getConnection(), getTable(), localStartKey, cacheNum, rpcControllerFactory);
     if (this.scanMetrics != null && skipRowOfFirstResult == null) {
       this.scanMetrics.countOfRegions.incrementAndGet();
@@ -171,36 +204,6 @@ public class ClientSmallScanner extends ClientScanner {
     return true;
   }
 
-  static RegionServerCallable<Result[]> getSmallScanCallable(
-      final Scan sc, HConnection connection, TableName table, byte[] localStartKey,
-      final int cacheNum, final RpcControllerFactory rpcControllerFactory) throws IOException { 
-    sc.setStartRow(localStartKey);
-    RegionServerCallable<Result[]> callable = new RegionServerCallable<Result[]>(
-        connection, table, sc.getStartRow()) {
-      public Result[] call() throws IOException {
-        ScanRequest request = RequestConverter.buildScanRequest(getLocation()
-          .getRegionInfo().getRegionName(), sc, cacheNum, true);
-        ScanResponse response = null;
-        PayloadCarryingRpcController controller = rpcControllerFactory.newController();
-        try {
-          controller.setPriority(getTableName());
-          response = getStub().scan(controller, request);
-          if (response.hasMoreResultsInRegion()) {
-            setHasMoreResultsContext(true);
-            setServerHasMoreResults(response.getMoreResultsInRegion());
-          } else {
-            setHasMoreResultsContext(false);
-          }
-          return ResponseConverter.getResults(controller.cellScanner(),
-              response);
-        } catch (ServiceException se) {
-          throw ProtobufUtil.getRemoteException(se);
-        }
-      }
-    };
-    return callable;
-  }
-
   @Override
   public Result next() throws IOException {
     // If the scanner is closed and there's nothing left in the cache, next is a
@@ -209,43 +212,7 @@ public class ClientSmallScanner extends ClientScanner {
       return null;
     }
     if (cache.size() == 0) {
-      Result[] values = null;
-      long remainingResultSize = maxScannerResultSize;
-      int countdown = this.caching;
-      boolean currentRegionDone = false;
-      // Values == null means server-side filter has determined we must STOP
-      while (remainingResultSize > 0 && countdown > 0
-          && nextScanner(countdown, values == null, currentRegionDone)) {
-        // Server returns a null values if scanning is to stop. Else,
-        // returns an empty array if scanning is to go on and we've just
-        // exhausted current region.
-        // TODO Use the server's response about more results
-        values = this.caller.callWithRetries(smallScanCallable);
-        this.currentRegion = smallScanCallable.getHRegionInfo();
-        long currentTime = System.currentTimeMillis();
-        if (this.scanMetrics != null) {
-          this.scanMetrics.sumOfMillisSecBetweenNexts.addAndGet(currentTime
-              - lastNext);
-        }
-        lastNext = currentTime;
-        if (values != null && values.length > 0) {
-          for (int i = 0; i < values.length; i++) {
-            Result rs = values[i];
-            if (i == 0 && this.skipRowOfFirstResult != null
-                && Bytes.equals(skipRowOfFirstResult, rs.getRow())) {
-              // Skip the first result
-              continue;
-            }
-            cache.add(rs);
-            for (Cell kv : rs.rawCells()) {
-              remainingResultSize -= KeyValueUtil.ensureKeyValue(kv).heapSize();
-            }
-            countdown--;
-            this.lastResult = rs;
-          }
-        }
-        currentRegionDone = countdown > 0;
-      }
+      loadCache();
     }
 
     if (cache.size() > 0) {
@@ -258,8 +225,103 @@ public class ClientSmallScanner extends ClientScanner {
   }
 
   @Override
+  protected void loadCache() throws IOException {
+    Result[] values = null;
+    long remainingResultSize = maxScannerResultSize;
+    int countdown = this.caching;
+    boolean currentRegionDone = false;
+    // Values == null means server-side filter has determined we must STOP
+    while (remainingResultSize > 0 && countdown > 0
+        && nextScanner(countdown, values == null, currentRegionDone)) {
+      // Server returns a null values if scanning is to stop. Else,
+      // returns an empty array if scanning is to go on and we've just
+      // exhausted current region.
+      values = this.caller.callWithRetries(smallScanCallable);
+      this.currentRegion = smallScanCallable.getHRegionInfo();
+      long currentTime = System.currentTimeMillis();
+      if (this.scanMetrics != null) {
+        this.scanMetrics.sumOfMillisSecBetweenNexts.addAndGet(currentTime
+            - lastNext);
+      }
+      lastNext = currentTime;
+      if (values != null && values.length > 0) {
+        for (int i = 0; i < values.length; i++) {
+          Result rs = values[i];
+          if (i == 0 && this.skipRowOfFirstResult != null
+              && Bytes.equals(skipRowOfFirstResult, rs.getRow())) {
+            // Skip the first result
+            continue;
+          }
+          cache.add(rs);
+          for (Cell kv : rs.rawCells()) {
+            remainingResultSize -= KeyValueUtil.ensureKeyValue(kv).heapSize();
+          }
+          countdown--;
+          this.lastResult = rs;
+        }
+      }
+      if (smallScanCallable.hasMoreResultsContext()) {
+        // If the server has more results, the current region is not done
+        currentRegionDone = !smallScanCallable.getServerHasMoreResults();
+      } else {
+        // not guaranteed to get the context in older versions, fall back to checking countdown
+        currentRegionDone = countdown > 0;
+      }
+    }
+  }
+
   public void close() {
     if (!scanMetricsPublished) writeScanMetrics();
     closed = true;
   }
+
+  @VisibleForTesting
+  protected void setScannerCallableFactory(SmallScannerCallableFactory callableFactory) {
+    this.callableFactory = callableFactory;
+  }
+
+  @VisibleForTesting
+  protected void setRpcRetryingCaller(RpcRetryingCaller<Result []> caller) {
+    this.caller = caller;
+  }
+
+  @VisibleForTesting
+  protected void setRpcControllerFactory(RpcControllerFactory rpcControllerFactory) {
+    this.rpcControllerFactory = rpcControllerFactory;
+  }
+
+  @InterfaceAudience.Private
+  protected static class SmallScannerCallableFactory {
+
+    public RegionServerCallable<Result[]> getCallable(final Scan sc, HConnection connection,
+        TableName table, byte[] localStartKey, final int cacheNum,
+        final RpcControllerFactory rpcControllerFactory) throws IOException {
+      sc.setStartRow(localStartKey);
+      RegionServerCallable<Result[]> callable = new RegionServerCallable<Result[]>(
+          connection, table, sc.getStartRow()) {
+        public Result[] call() throws IOException {
+          ScanRequest request = RequestConverter.buildScanRequest(getLocation()
+            .getRegionInfo().getRegionName(), sc, cacheNum, true);
+          ScanResponse response = null;
+          PayloadCarryingRpcController controller = rpcControllerFactory.newController();
+          try {
+            controller.setPriority(getTableName());
+            response = getStub().scan(controller, request);
+            if (response.hasMoreResultsInRegion()) {
+              setHasMoreResultsContext(true);
+              setServerHasMoreResults(response.getMoreResultsInRegion());
+            } else {
+              setHasMoreResultsContext(false);
+            }
+            return ResponseConverter.getResults(controller.cellScanner(),
+                response);
+          } catch (ServiceException se) {
+            throw ProtobufUtil.getRemoteException(se);
+          }
+        }
+      };
+      return callable;
+    }
+
+  }
 }
diff --git a/hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestClientSmallReversedScanner.java b/hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestClientSmallReversedScanner.java
new file mode 100644
index 0000000..07cb156
--- /dev/null
+++ b/hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestClientSmallReversedScanner.java
@@ -0,0 +1,372 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.client;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.util.Iterator;
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.hbase.Cell;
+import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.HRegionInfo;
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.KeyValue.Type;
+import org.apache.hadoop.hbase.SmallTests;
+import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.client.ClientSmallScanner.SmallScannerCallableFactory;
+import org.apache.hadoop.hbase.ipc.RpcControllerFactory;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+import org.mockito.Mockito;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+/**
+ * Test the ClientSmallReversedScanner.
+ */
+@Category(SmallTests.class)
+public class TestClientSmallReversedScanner {
+
+  Scan scan;
+  ExecutorService pool;
+  Configuration conf;
+
+  HConnection clusterConn;
+  RpcRetryingCallerFactory rpcFactory;
+  RpcControllerFactory controllerFactory;
+  RpcRetryingCaller<Result[]> caller;
+
+  @Before
+  @SuppressWarnings("unchecked")
+  public void setup() throws IOException {
+    clusterConn = Mockito.mock(HConnection.class);
+    rpcFactory = Mockito.mock(RpcRetryingCallerFactory.class);
+    controllerFactory = Mockito.mock(RpcControllerFactory.class);
+    pool = Executors.newSingleThreadExecutor();
+    scan = new Scan();
+    conf = new Configuration();
+    Mockito.when(clusterConn.getConfiguration()).thenReturn(conf);
+    // Mock out the RpcCaller
+    caller = Mockito.mock(RpcRetryingCaller.class);
+    // Return the mock from the factory
+    Mockito.when(rpcFactory.<Result[]> newCaller()).thenReturn(caller);
+  }
+
+  @After
+  public void teardown() {
+    if (null != pool) {
+      pool.shutdownNow();
+    }
+  }
+
+  /**
+   * Create a simple Answer which returns true the first time, and false every time after.
+   */
+  private Answer<Boolean> createTrueThenFalseAnswer() {
+    return new Answer<Boolean>() {
+      boolean first = true;
+
+      @Override
+      public Boolean answer(InvocationOnMock invocation) {
+        if (first) {
+          first = false;
+          return true;
+        }
+        return false;
+      }
+    };
+  }
+
+  private SmallScannerCallableFactory getFactory(
+      final RegionServerCallable<Result[]> callableWithReplicas) {
+    return new SmallScannerCallableFactory() {
+      @Override
+      public RegionServerCallable<Result[]> getCallable(final Scan sc, HConnection connection,
+          TableName table, byte[] localStartKey, final int cacheNum,
+          final RpcControllerFactory rpcControllerFactory) {
+        return callableWithReplicas;
+      }
+    };
+  }
+
+  @Test
+  public void testContextPresent() throws Exception {
+    final KeyValue kv1 = new KeyValue("row1".getBytes(), "cf".getBytes(), "cq".getBytes(), 1,
+        Type.Maximum), kv2 = new KeyValue("row2".getBytes(), "cf".getBytes(), "cq".getBytes(), 1,
+        Type.Maximum), kv3 = new KeyValue("row3".getBytes(), "cf".getBytes(), "cq".getBytes(), 1,
+        Type.Maximum);
+
+    @SuppressWarnings("unchecked")
+    RegionServerCallable<Result[]> callableWithReplicas = Mockito
+        .mock(RegionServerCallable.class);
+
+    // Mock out the RpcCaller
+    @SuppressWarnings("unchecked")
+    RpcRetryingCaller<Result[]> caller = Mockito.mock(RpcRetryingCaller.class);
+    // Return the mock from the factory
+    Mockito.when(rpcFactory.<Result[]> newCaller()).thenReturn(caller);
+
+    // Intentionally leave a "default" caching size in the Scan. No matter the value, we
+    // should continue based on the server context
+
+    SmallScannerCallableFactory factory = getFactory(callableWithReplicas);
+
+    ClientSmallReversedScanner csrs = new ClientSmallReversedScanner(conf, scan,
+        TableName.valueOf("table"), clusterConn);
+
+    try {
+      csrs.setRpcRetryingCaller(caller);
+      csrs.setRpcControllerFactory(controllerFactory);
+      csrs.setScannerCallableFactory(factory);
+
+      // Return some data the first time, less the second, and none after that
+      Mockito.when(
+          caller.callWithRetries(callableWithReplicas,
+              HConstants.DEFAULT_HBASE_CLIENT_SCANNER_TIMEOUT_PERIOD)).thenAnswer(
+          new Answer<Result[]>() {
+            int count = 0;
+
+            @Override
+            public Result[] answer(InvocationOnMock invocation) {
+              Result[] results;
+              if (0 == count) {
+                results = new Result[] {Result.create(new Cell[] {kv3}),
+                    Result.create(new Cell[] {kv2})};
+              } else if (1 == count) {
+                results = new Result[] {Result.create(new Cell[] {kv1})};
+              } else {
+                results = new Result[0];
+              }
+              count++;
+              return results;
+            }
+          });
+
+      // Pass back the context always
+      Mockito.when(callableWithReplicas.hasMoreResultsContext()).thenReturn(true);
+      // Only have more results the first time
+      Mockito.when(callableWithReplicas.getServerHasMoreResults()).thenAnswer(
+          createTrueThenFalseAnswer());
+
+      // A mocked HRegionInfo so ClientSmallScanner#nextScanner(...) works right
+      HRegionInfo regionInfo = Mockito.mock(HRegionInfo.class);
+      Mockito.when(callableWithReplicas.getHRegionInfo()).thenReturn(regionInfo);
+      // Trigger the "no more data" branch for #nextScanner(...)
+      Mockito.when(regionInfo.getEndKey()).thenReturn(HConstants.EMPTY_BYTE_ARRAY);
+
+      csrs.loadCache();
+
+      List<Result> results = csrs.cache;
+      Iterator<Result> iter = results.iterator();
+      assertEquals(3, results.size());
+      for (int i = 3; i >= 1 && iter.hasNext(); i--) {
+        Result result = iter.next();
+        byte[] row = result.getRow();
+        assertEquals("row" + i, new String(row, StandardCharsets.UTF_8));
+        assertEquals(1, result.getMap().size());
+      }
+      assertTrue(csrs.closed);
+    } finally {
+      csrs.close();
+    }
+  }
+
+  @Test
+  public void testNoContextFewerRecords() throws Exception {
+    final KeyValue kv1 = new KeyValue("row1".getBytes(), "cf".getBytes(), "cq".getBytes(), 1,
+        Type.Maximum), kv2 = new KeyValue("row2".getBytes(), "cf".getBytes(), "cq".getBytes(), 1,
+        Type.Maximum), kv3 = new KeyValue("row3".getBytes(), "cf".getBytes(), "cq".getBytes(), 1,
+        Type.Maximum);
+
+    @SuppressWarnings("unchecked")
+    RegionServerCallable<Result[]> callableWithReplicas = Mockito
+        .mock(RegionServerCallable.class);
+
+    // While the server returns 2 records per batch, we expect more records.
+    scan.setCaching(2);
+
+    SmallScannerCallableFactory factory = getFactory(callableWithReplicas);
+
+    ClientSmallReversedScanner csrs = new ClientSmallReversedScanner(conf, scan,
+        TableName.valueOf("table"), clusterConn);
+
+    try {
+      csrs.setRpcRetryingCaller(caller);
+      csrs.setRpcControllerFactory(controllerFactory);
+      csrs.setScannerCallableFactory(factory);
+
+      // Return some data the first time, less the second, and none after that
+      Mockito.when(
+          caller.callWithRetries(callableWithReplicas,
+              HConstants.DEFAULT_HBASE_CLIENT_SCANNER_TIMEOUT_PERIOD)).thenAnswer(
+          new Answer<Result[]>() {
+            int count = 0;
+
+            @Override
+            public Result[] answer(InvocationOnMock invocation) {
+              Result[] results;
+              if (0 == count) {
+                results = new Result[] {Result.create(new Cell[] {kv3}),
+                    Result.create(new Cell[] {kv2})};
+              } else if (1 == count) {
+                // Return fewer records than expected (2)
+                results = new Result[] {Result.create(new Cell[] {kv1})};
+              } else {
+                throw new RuntimeException("Should not fetch a third batch from the server");
+              }
+              count++;
+              return results;
+            }
+          });
+
+      // Server doesn't return the context
+      Mockito.when(callableWithReplicas.hasMoreResultsContext()).thenReturn(false);
+      // getServerHasMoreResults shouldn't be called when hasMoreResultsContext returns false
+      Mockito.when(callableWithReplicas.getServerHasMoreResults())
+          .thenThrow(new RuntimeException("Should not be called"));
+
+      // A mocked HRegionInfo so ClientSmallScanner#nextScanner(...) works right
+      HRegionInfo regionInfo = Mockito.mock(HRegionInfo.class);
+      Mockito.when(callableWithReplicas.getHRegionInfo()).thenReturn(regionInfo);
+      // Trigger the "no more data" branch for #nextScanner(...)
+      Mockito.when(regionInfo.getEndKey()).thenReturn(HConstants.EMPTY_BYTE_ARRAY);
+
+      csrs.loadCache();
+
+      List<Result> results = csrs.cache;
+      Iterator<Result> iter = results.iterator();
+      assertEquals(2, results.size());
+      for (int i = 3; i >= 2 && iter.hasNext(); i--) {
+        Result result = iter.next();
+        byte[] row = result.getRow();
+        assertEquals("row" + i, new String(row, StandardCharsets.UTF_8));
+        assertEquals(1, result.getMap().size());
+      }
+
+      // "consume" the Results
+      results.clear();
+
+      csrs.loadCache();
+
+      assertEquals(1, results.size());
+      Result result = results.get(0);
+      assertEquals("row1", new String(result.getRow(), StandardCharsets.UTF_8));
+      assertEquals(1, result.getMap().size());
+
+      assertTrue(csrs.closed);
+    } finally {
+      csrs.close();
+    }
+  }
+
+  @Test
+  public void testNoContextNoRecords() throws Exception {
+    @SuppressWarnings("unchecked")
+    RegionServerCallable<Result[]> callableWithReplicas = Mockito
+        .mock(RegionServerCallable.class);
+
+    // While the server return 2 records per RPC, we expect there to be more records.
+    scan.setCaching(2);
+
+    SmallScannerCallableFactory factory = getFactory(callableWithReplicas);
+
+    ClientSmallReversedScanner csrs = new ClientSmallReversedScanner(conf, scan,
+        TableName.valueOf("table"), clusterConn);
+
+    try {
+      csrs.setRpcRetryingCaller(caller);
+      csrs.setRpcControllerFactory(controllerFactory);
+      csrs.setScannerCallableFactory(factory);
+
+      // Return some data the first time, less the second, and none after that
+      Mockito.when(
+          caller.callWithRetries(callableWithReplicas,
+              HConstants.DEFAULT_HBASE_CLIENT_SCANNER_TIMEOUT_PERIOD)).thenReturn(new Result[0]);
+
+      // Server doesn't return the context
+      Mockito.when(callableWithReplicas.hasMoreResultsContext()).thenReturn(false);
+      // Only have more results the first time
+      Mockito.when(callableWithReplicas.getServerHasMoreResults())
+          .thenThrow(new RuntimeException("Should not be called"));
+
+      // A mocked HRegionInfo so ClientSmallScanner#nextScanner(...) works right
+      HRegionInfo regionInfo = Mockito.mock(HRegionInfo.class);
+      Mockito.when(callableWithReplicas.getHRegionInfo()).thenReturn(regionInfo);
+      // Trigger the "no more data" branch for #nextScanner(...)
+      Mockito.when(regionInfo.getEndKey()).thenReturn(HConstants.EMPTY_BYTE_ARRAY);
+
+      csrs.loadCache();
+
+      assertEquals(0, csrs.cache.size());
+      assertTrue(csrs.closed);
+    } finally {
+      csrs.close();
+    }
+  }
+
+  @Test
+  public void testContextNoRecords() throws Exception {
+    @SuppressWarnings("unchecked")
+    RegionServerCallable<Result[]> callableWithReplicas = Mockito
+        .mock(RegionServerCallable.class);
+
+    SmallScannerCallableFactory factory = getFactory(callableWithReplicas);
+
+    ClientSmallReversedScanner csrs = new ClientSmallReversedScanner(conf, scan,
+        TableName.valueOf("table"), clusterConn);
+
+    try {
+      csrs.setRpcRetryingCaller(caller);
+      csrs.setRpcControllerFactory(controllerFactory);
+      csrs.setScannerCallableFactory(factory);
+
+      // Return some data the first time, less the second, and none after that
+      Mockito.when(
+          caller.callWithRetries(callableWithReplicas,
+              HConstants.DEFAULT_HBASE_CLIENT_SCANNER_TIMEOUT_PERIOD)).thenReturn(new Result[0]);
+
+      // Server doesn't return the context
+      Mockito.when(callableWithReplicas.hasMoreResultsContext()).thenReturn(true);
+      // Only have more results the first time
+      Mockito.when(callableWithReplicas.getServerHasMoreResults())
+          .thenReturn(false);
+
+      // A mocked HRegionInfo so ClientSmallScanner#nextScanner(...) works right
+      HRegionInfo regionInfo = Mockito.mock(HRegionInfo.class);
+      Mockito.when(callableWithReplicas.getHRegionInfo()).thenReturn(regionInfo);
+      // Trigger the "no more data" branch for #nextScanner(...)
+      Mockito.when(regionInfo.getEndKey()).thenReturn(HConstants.EMPTY_BYTE_ARRAY);
+
+      csrs.loadCache();
+
+      assertEquals(0, csrs.cache.size());
+      assertTrue(csrs.closed);
+    } finally {
+      csrs.close();
+    }
+  }
+}
diff --git a/hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestClientSmallScanner.java b/hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestClientSmallScanner.java
new file mode 100644
index 0000000..42734c2
--- /dev/null
+++ b/hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestClientSmallScanner.java
@@ -0,0 +1,352 @@
+/**
+ * Licensed to the Apache Software Foundation (ASF) under one
+ * or more contributor license agreements.  See the NOTICE file
+ * distributed with this work for additional information
+ * regarding copyright ownership.  The ASF licenses this file
+ * to you under the Apache License, Version 2.0 (the
+ * "License"); you may not use this file except in compliance
+ * with the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package org.apache.hadoop.hbase.client;
+
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertTrue;
+
+import java.io.IOException;
+import java.nio.charset.StandardCharsets;
+import java.util.List;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.hbase.Cell;
+import org.apache.hadoop.hbase.HConstants;
+import org.apache.hadoop.hbase.HRegionInfo;
+import org.apache.hadoop.hbase.KeyValue;
+import org.apache.hadoop.hbase.KeyValue.Type;
+import org.apache.hadoop.hbase.SmallTests;
+import org.apache.hadoop.hbase.TableName;
+import org.apache.hadoop.hbase.client.ClientSmallScanner.SmallScannerCallableFactory;
+import org.apache.hadoop.hbase.ipc.RpcControllerFactory;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.junit.experimental.categories.Category;
+import org.mockito.Mockito;
+import org.mockito.invocation.InvocationOnMock;
+import org.mockito.stubbing.Answer;
+
+/**
+ * Test the ClientSmallScanner.
+ */
+@Category(SmallTests.class)
+public class TestClientSmallScanner {
+
+  Scan scan;
+  ExecutorService pool;
+  Configuration conf;
+
+  HConnection clusterConn;
+  RpcRetryingCallerFactory rpcFactory;
+  RpcControllerFactory controllerFactory;
+  RpcRetryingCaller<Result[]> caller;
+
+  @Before
+  @SuppressWarnings("unchecked")
+  public void setup() throws IOException {
+    clusterConn = Mockito.mock(HConnection.class);
+    rpcFactory = Mockito.mock(RpcRetryingCallerFactory.class);
+    controllerFactory = Mockito.mock(RpcControllerFactory.class);
+    pool = Executors.newSingleThreadExecutor();
+    scan = new Scan();
+    conf = new Configuration();
+    Mockito.when(clusterConn.getConfiguration()).thenReturn(conf);
+    // Mock out the RpcCaller
+    caller = Mockito.mock(RpcRetryingCaller.class);
+    // Return the mock from the factory
+    Mockito.when(rpcFactory.<Result[]> newCaller()).thenReturn(caller);
+  }
+
+  @After
+  public void teardown() {
+    if (null != pool) {
+      pool.shutdownNow();
+    }
+  }
+
+  /**
+   * Create a simple Answer which returns true the first time, and false every time after.
+   */
+  private Answer<Boolean> createTrueThenFalseAnswer() {
+    return new Answer<Boolean>() {
+      boolean first = true;
+
+      @Override
+      public Boolean answer(InvocationOnMock invocation) {
+        if (first) {
+          first = false;
+          return true;
+        }
+        return false;
+      }
+    };
+  }
+
+  private SmallScannerCallableFactory getFactory(
+      final RegionServerCallable<Result[]> callableWithReplicas) {
+    return new SmallScannerCallableFactory() {
+      @Override
+      public RegionServerCallable<Result[]> getCallable(final Scan sc, HConnection connection,
+          TableName table, byte[] localStartKey, final int cacheNum,
+          final RpcControllerFactory rpcControllerFactory) {
+        return callableWithReplicas;
+      }
+    };
+  }
+
+  @Test
+  public void testContextPresent() throws Exception {
+    final KeyValue kv1 = new KeyValue("row1".getBytes(), "cf".getBytes(), "cq".getBytes(), 1,
+        Type.Maximum), kv2 = new KeyValue("row2".getBytes(), "cf".getBytes(), "cq".getBytes(), 1,
+        Type.Maximum), kv3 = new KeyValue("row3".getBytes(), "cf".getBytes(), "cq".getBytes(), 1,
+        Type.Maximum);
+
+    @SuppressWarnings("unchecked")
+    RegionServerCallable<Result[]> callableWithReplicas = Mockito
+        .mock(RegionServerCallable.class);
+
+    // Mock out the RpcCaller
+    @SuppressWarnings("unchecked")
+    RpcRetryingCaller<Result[]> caller = Mockito.mock(RpcRetryingCaller.class);
+    // Return the mock from the factory
+    Mockito.when(rpcFactory.<Result[]> newCaller()).thenReturn(caller);
+
+    SmallScannerCallableFactory factory = getFactory(callableWithReplicas);
+
+    // Intentionally leave a "default" caching size in the Scan. No matter the value, we
+    // should continue based on the server context
+
+    ClientSmallScanner css = new ClientSmallScanner(conf, scan, TableName.valueOf("table"),
+        clusterConn);
+    try {
+      css.setRpcRetryingCaller(caller);
+      css.setRpcControllerFactory(controllerFactory);
+      css.setScannerCallableFactory(factory);
+
+      // Return some data the first time, less the second, and none after that
+      Mockito.when(caller.callWithRetries(callableWithReplicas)).thenAnswer(new Answer<Result[]>() {
+        int count = 0;
+
+        @Override
+        public Result[] answer(InvocationOnMock invocation) {
+          Result[] results;
+          if (0 == count) {
+            results = new Result[] {Result.create(new Cell[] {kv1}),
+                Result.create(new Cell[] {kv2})};
+          } else if (1 == count) {
+            results = new Result[] {Result.create(new Cell[] {kv3})};
+          } else {
+            results = new Result[0];
+          }
+          count++;
+          return results;
+        }
+      });
+
+      // Pass back the context always
+      Mockito.when(callableWithReplicas.hasMoreResultsContext()).thenReturn(true);
+      // Only have more results the first time
+      Mockito.when(callableWithReplicas.getServerHasMoreResults()).thenAnswer(
+          createTrueThenFalseAnswer());
+
+      // A mocked HRegionInfo so ClientSmallScanner#nextScanner(...) works right
+      HRegionInfo regionInfo = Mockito.mock(HRegionInfo.class);
+      Mockito.when(callableWithReplicas.getHRegionInfo()).thenReturn(regionInfo);
+      // Trigger the "no more data" branch for #nextScanner(...)
+      Mockito.when(regionInfo.getEndKey()).thenReturn(HConstants.EMPTY_BYTE_ARRAY);
+
+      css.loadCache();
+
+      List<Result> results = css.cache;
+      assertEquals(3, results.size());
+      for (int i = 1; i <= 3; i++) {
+        Result result = results.get(i - 1);
+        byte[] row = result.getRow();
+        assertEquals("row" + i, new String(row, StandardCharsets.UTF_8));
+        assertEquals(1, result.getMap().size());
+      }
+
+      assertTrue(css.closed);
+    } finally {
+      css.close();
+    }
+  }
+
+  @Test
+  public void testNoContextFewerRecords() throws Exception {
+    final KeyValue kv1 = new KeyValue("row1".getBytes(), "cf".getBytes(), "cq".getBytes(), 1,
+        Type.Maximum), kv2 = new KeyValue("row2".getBytes(), "cf".getBytes(), "cq".getBytes(), 1,
+        Type.Maximum), kv3 = new KeyValue("row3".getBytes(), "cf".getBytes(), "cq".getBytes(), 1,
+        Type.Maximum);
+
+    @SuppressWarnings("unchecked")
+    RegionServerCallable<Result[]> callableWithReplicas = Mockito
+        .mock(RegionServerCallable.class);
+
+    // While the server returns 2 records per batch, we expect more records.
+    scan.setCaching(2);
+    SmallScannerCallableFactory factory = getFactory(callableWithReplicas);
+
+    ClientSmallScanner css = new ClientSmallScanner(conf, scan, TableName.valueOf("table"),
+        clusterConn);
+    try {
+      css.setRpcRetryingCaller(caller);
+      css.setRpcControllerFactory(controllerFactory);
+      css.setScannerCallableFactory(factory);
+      // Return some data the first time, less the second, and none after that
+      Mockito.when(caller.callWithRetries(callableWithReplicas)).thenAnswer(new Answer<Result[]>() {
+        int count = 0;
+
+        @Override
+        public Result[] answer(InvocationOnMock invocation) {
+          Result[] results;
+          if (0 == count) {
+            results = new Result[] {Result.create(new Cell[] {kv1}),
+                Result.create(new Cell[] {kv2})};
+          } else if (1 == count) {
+            // Return fewer records than expected (2)
+            results = new Result[] {Result.create(new Cell[] {kv3})};
+          } else {
+            throw new RuntimeException("Should not fetch a third batch from the server");
+          }
+          count++;
+          return results;
+        }
+      });
+
+      // Server doesn't return the context
+      Mockito.when(callableWithReplicas.hasMoreResultsContext()).thenReturn(false);
+      // Only have more results the first time
+      Mockito.when(callableWithReplicas.getServerHasMoreResults()).thenThrow(
+          new RuntimeException("Should not be called"));
+
+      // A mocked HRegionInfo so ClientSmallScanner#nextScanner(...) works right
+      HRegionInfo regionInfo = Mockito.mock(HRegionInfo.class);
+      Mockito.when(callableWithReplicas.getHRegionInfo()).thenReturn(regionInfo);
+      // Trigger the "no more data" branch for #nextScanner(...)
+      Mockito.when(regionInfo.getEndKey()).thenReturn(HConstants.EMPTY_BYTE_ARRAY);
+
+      css.loadCache();
+
+      List<Result> results = css.cache;
+      assertEquals(2, results.size());
+      for (int i = 1; i <= 2; i++) {
+        Result result = results.get(i - 1);
+        byte[] row = result.getRow();
+        assertEquals("row" + i, new String(row, StandardCharsets.UTF_8));
+        assertEquals(1, result.getMap().size());
+      }
+
+      // "consume" the results we verified
+      results.clear();
+
+      css.loadCache();
+
+      assertEquals(1, results.size());
+      Result result = results.get(0);
+      assertEquals("row3", new String(result.getRow(), StandardCharsets.UTF_8));
+      assertEquals(1, result.getMap().size());
+      assertTrue(css.closed);
+    } finally {
+      css.close();
+    }
+  }
+
+  @Test
+  public void testNoContextNoRecords() throws Exception {
+    @SuppressWarnings("unchecked")
+    RegionServerCallable<Result[]> callableWithReplicas = Mockito
+        .mock(RegionServerCallable.class);
+
+    // While the server return 2 records per RPC, we expect there to be more records.
+    scan.setCaching(2);
+
+    SmallScannerCallableFactory factory = getFactory(callableWithReplicas);
+
+    ClientSmallScanner css = new ClientSmallScanner(conf, scan, TableName.valueOf("table"),
+        clusterConn);
+    try {
+      css.setRpcRetryingCaller(caller);
+      css.setRpcControllerFactory(controllerFactory);
+      css.setScannerCallableFactory(factory);
+
+      // Return some data the first time, less the second, and none after that
+      Mockito.when(caller.callWithRetries(callableWithReplicas)).thenReturn(new Result[0]);
+
+      // Server doesn't return the context
+      Mockito.when(callableWithReplicas.hasMoreResultsContext()).thenReturn(false);
+      // Only have more results the first time
+      Mockito.when(callableWithReplicas.getServerHasMoreResults()).thenThrow(
+          new RuntimeException("Should not be called"));
+
+      // A mocked HRegionInfo so ClientSmallScanner#nextScanner(...) works right
+      HRegionInfo regionInfo = Mockito.mock(HRegionInfo.class);
+      Mockito.when(callableWithReplicas.getHRegionInfo()).thenReturn(regionInfo);
+      // Trigger the "no more data" branch for #nextScanner(...)
+      Mockito.when(regionInfo.getEndKey()).thenReturn(HConstants.EMPTY_BYTE_ARRAY);
+
+      css.loadCache();
+
+      assertEquals(0, css.cache.size());
+      assertTrue(css.closed);
+    } finally {
+      css.close();
+    }
+  }
+
+  @Test
+  public void testContextNoRecords() throws Exception {
+    @SuppressWarnings("unchecked")
+    RegionServerCallable<Result[]> callableWithReplicas = Mockito
+        .mock(RegionServerCallable.class);
+
+    SmallScannerCallableFactory factory = getFactory(callableWithReplicas);
+
+    ClientSmallScanner css = new ClientSmallScanner(conf, scan, TableName.valueOf("table"),
+        clusterConn);
+    try {
+      css.setRpcRetryingCaller(caller);
+      css.setRpcControllerFactory(controllerFactory);
+      css.setScannerCallableFactory(factory);
+
+      // Return some data the first time, less the second, and none after that
+      Mockito.when(caller.callWithRetries(callableWithReplicas)).thenReturn(new Result[0]);
+
+      // Server doesn't return the context
+      Mockito.when(callableWithReplicas.hasMoreResultsContext()).thenReturn(true);
+      // Only have more results the first time
+      Mockito.when(callableWithReplicas.getServerHasMoreResults()).thenReturn(false);
+
+      // A mocked HRegionInfo so ClientSmallScanner#nextScanner(...) works right
+      HRegionInfo regionInfo = Mockito.mock(HRegionInfo.class);
+      Mockito.when(callableWithReplicas.getHRegionInfo()).thenReturn(regionInfo);
+      // Trigger the "no more data" branch for #nextScanner(...)
+      Mockito.when(regionInfo.getEndKey()).thenReturn(HConstants.EMPTY_BYTE_ARRAY);
+
+      css.loadCache();
+
+      assertEquals(0, css.cache.size());
+      assertTrue(css.closed);
+    } finally {
+      css.close();
+    }
+  }
+}
-- 
1.7.9.5

